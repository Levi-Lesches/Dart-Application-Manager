import 'dart:io';

import 'package:dam/data.dart';
import 'package:dam/utils.dart';

import "service.dart";

// NOTE: DO NOT CHANGE. This is used to identify DAM-written files.
String _header = "# This service was auto-generated by the DAM tool";

String _template({
  required String name,
  required Directory dir,
  required String executable,
}) => """
$_header
# See ${dir.absolutePath}/dam.yaml for more details.

[Unit]
Description="$name"
After=network-online.target

[Service]
WorkingDirectory=${dir.absolutePath}
ExecStart=${dir.absolutePath}/$executable
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
""";

class SystemdService extends AppService<SystemdConfig> {
  @override
  String generate(App app, SystemdConfig config) =>
    _template(name: app.name, dir: app.dir, executable: config.executableCommand);

  // TODO: Put the file somewhere else.
  // See: systemd-analyze --user unit-paths
  File getServiceFile(App app) => File("/etc/systemd/service/${app.name}.service");

  Future<void> checkIfSafe(File file) async {
    if (!await file.isSafeToWrite(_header)) {
      throw DamError("The service file ${file.path} is already registered to another service");
    }
  }

  @override
  Future<bool> isInstalled(App app) async {
    final file = getServiceFile(app);
    return await file.isInstalledByDam(_header);
  }

  @override
  Future<void> install(App app, SystemdConfig config) async {
    final contents = generate(app, config);
    final file = getServiceFile(app);
    await checkIfSafe(file);
    await file.writeAsString(contents);
    await Process.run("sudo", ["systemctl", "enable", app.name]);
    await Process.run("sudo", ["systemctl", "start", "service"]);
  }

  @override
  Future<void> uninstall(App app) async {
    await Process.run("sudo", ["systemctl", "stop", "service"]);
    await Process.run("sudo", ["systemctl", "disable", "service"]);
    final file = getServiceFile(app);
    await checkIfSafe(file);
    await file.delete();
  }
}
